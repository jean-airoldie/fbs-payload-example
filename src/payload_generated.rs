// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod payload {
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    pub enum PayloadOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Payload<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Payload<'a> {
        type Inner = Payload<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Payload<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Payload { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PayloadArgs<'args>,
        ) -> flatbuffers::WIPOffset<Payload<'bldr>> {
            let mut builder = PayloadBuilder::new(_fbb);
            if let Some(x) = args.messages {
                builder.add_messages(x);
            }
            builder.finish()
        }

        pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn messages(
            &self,
        ) -> Option<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Message<'a>>>,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Message<'a>>>,
            >>(Payload::VT_MESSAGES, None)
        }
    }

    pub struct PayloadArgs<'a> {
        pub messages: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<Message<'a>>,
                >,
            >,
        >,
    }
    impl<'a> Default for PayloadArgs<'a> {
        #[inline]
        fn default() -> Self {
            PayloadArgs { messages: None }
        }
    }
    pub struct PayloadBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PayloadBuilder<'a, 'b> {
        #[inline]
        pub fn add_messages(
            &mut self,
            messages: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<Message<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Payload::VT_MESSAGES,
                messages,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PayloadBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PayloadBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Payload<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum MessageOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Message<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Message<'a> {
        type Inner = Message<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Message<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Message { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageArgs,
        ) -> flatbuffers::WIPOffset<Message<'bldr>> {
            let mut builder = MessageBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> u32 {
            self._tab.get::<u32>(Message::VT_VALUE, Some(0)).unwrap()
        }
    }

    pub struct MessageArgs {
        pub value: u32,
    }
    impl<'a> Default for MessageArgs {
        #[inline]
        fn default() -> Self {
            MessageArgs { value: 0 }
        }
    }
    pub struct MessageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

} // pub mod payload
